# PDFScript

A transpiler for PDF: an improved and simplified language to create good looking documents.

PDFScript lets you focus on the page content while it handles the plumbing of creating a PDF file.

You create a PDFScript in a `.pdfs` file, and produce a PDF via the CLI or via the .net NuGet package, from within your own project.

## Example

The following is a valid `.pdfs` file that produces a one-page document:

```
1.0 0.2 0.8 rg 10 10 200 150 re f
```

The syntax of this minimal file is identical to the syntax of the ‘content stream’ inside the generated PDF file. PDFScript handles the stuff around this content.

## Why use PDFScript?

### Minimal syntax

PDFScript takes care of the binary formatting of a PDF document. A `.pdfs` file is text file that can be typed up by a human, or easily generated by some code. There is no need to worry about binary representation, precise location of content inside the file, and other details that make generating PDFs a time-consuming task.

In fact a `.pdfs` file consists only of content. Even a multi-page document can be expressed without the need of a document structure:

```
BT 1 0 0 1 20 810 Tm /TimeRoman 12 Tf (Hello, World!) Tj ET
endpage
BT 1 0 0 1 20 810 Tm /TimeRoman 12 Tf (Hello, page two!) Tj ET
```

### Additional features

The PDF file format is 30 years old and yet not much has changed in its core set of content instructions. Common and popular features like rounded rectangles or gradient fills are not available in the PDF specification, but you can use them in PDFScript.

```
# pattern /Grad1 /LinearGradient /DeviceRGB 10 10 200 150 1.0 0.2 0.8 0.7 0.2 1.0
# pattern /Grad1 /LinearGradient << /ColorSpace /DeviceRGB /Coords [10 10 200 150] /Colors [1.0 0.2 0.8, 0.7 0.2 1.0] >>

/Grad1 scn
10 10 200 150 10 10 rr f
```

This produces a page with a rounded rectangle (the `rr` instruction), filled with a linear gradient brush (defined by `lrg`).

The PDF content to make this happen is not something you’d want to type up yourself!

```
(STUFF)
```

### Syntax checking

When PDFScript parses a file with an invalid operand or unknown operation, it will stop processing and output an error onto the standard error output.

A PDF file with invalid content will sometimes accept the mistake, and sometimes stop rendering. This makes for slow and frustrating development.

### External resources

A PDF file contains all of the resources needed to render content. This means images and fonts are included inside of the PDF file, in their binary formats.

In addition, they need a lot of plumbing to work. Embedding a font in a PDF requires you include at least two sets of information about the font, and list the precise widths of its glyphs, and that’s before you get into character mappings, and making text selectable in PDF readers …

In a `.pdfs` file, you simply refer to the resources in the prologue, and then use them in your content in plain old PDF syntax.

```
# resource /Img1 /Image (https://coolimage.com)
# resource /MyRoboto /Font (http://fonts.google.com/Roboto/ttf)

320 0 0 320 10 450 /Img1 Do
BT /MyRoboto 12 Tf 1 0 0 1 10 430 Tm (Hello, Roboto!) Tj ET
```

PDFScript will take care of all of the necessary work to turn this into a valid PDF file. This includes embedding the image and the font, and figuring out how to handle the typeface.

### Unicode

PDF uses a binary file format that supports 7-bit ASCII text and allows for multi-byte encodings. Simply rendering a unicode string is a no-no. Not without understanding how to convert the codes into glyphs and output mappings into the file. Not without telling the PDF file how to convert the codes back into a unicode string so it can be selected and copied/pasted from a PDF viewer.

A `.pdfs` file is a text file and can be stored in `UTF-8` format. It also supports escape sequences like you’re used to from other languages.

```
# resource /Roboto /Font (http://fonts.google.com/Roboto/ttf)
BT
1 0 0 1 10 800 Tm /Roboto 12 Tf
(Hello, XXX <smilie>) Tj
ET
```

### Variables and dynamic content

With PDFScript, you can substitute any operand for a variable instead. Define a variable in the prologue, and use it in place of any operand whose type matches.

```
# var $fontSize /Number 12
# var $hello /String (Hello, World!)

BT
/TimesRoman $fontSize Tf
$hello Tj
ET
```

#### Dynamic content

In PDF, a ‘content stream’ is a set of operands and operations, and the /Stream variable type allows you to place template content anywhere in the content, subject to syntax checks passing of course!

```
# var $content /Content BT /TimesRoman 12 Tf (Hello, World!) Tj ET endstream

1 0 0 1 10 750 cm
$content
1 0 0 1  0 14 cm
$content
1 0 0 1  0 14 cm
$content
```

Note the `endstream` token at the end of the content. This serves two purposes: first it maintains consistency with the syntax for content streams in PDF files; secondly, it allows you to use line breaks in the content, as the processor will consider everything after `/Content` to be part of the content, up to the `endstream` token.

### Flowing text

Flowing text is not possible in PDFs. They render text on one line, and it’s up to the creator to figure out how to flow the text.

PDFScript adds support for text-flowing. The `Tfl` operation is the text-flow macro. It takes a rectangle and some parameters, and flows text within the container.

```
10 10 300 200 1 1 (The quick brown fox jumps over the lazy dog) Tfl
```

The parameters after the rectangle bounds control the horizontal and vertical alignment of the text within the container.

### Output variables

Variables declared in the prologue are exposed to the outside world. This means that the values can be overridden when using the API or the command line tool. They are referred to as ‘input’ variables.

PDFScript also uses ‘output’ variables, which are created as a consequence of the processing of the file. These variables are not exposed to the outside. They can be used to direct subsequent operations, however.

A good example is text measurement. The text operations (`Tj`, `TJ`, etc) measure their text and return the drawn width, which can be used to affect other operations. See the example below:

```
1 0 0 1 10 750 cm
BT /TimesRoman 12 Tf (Line of text) $width Tj ET
0.8 0 0 rg
10 750 m $width 0 l
```

This draws a red line across the width of the “Line of text” text.

The Tfl operation returns the width and height in two variables. The text-measure operation Tme also returns the width and height of text, but doesn’t render the text. This is useful when you need to render some appropriately sized content before rendering the text.

```
1 0 0 1 10 750 cm
BT
/TimesRoman 12 Tf
$width $height 200 150 (The quick brown fox jumps over the lazy dog) Tme
ET
0.9 0.9 0.9 RG
0 0 $width $height 10 10 rr f
BT
/TimesRoman 12 Tf
0 0 200 150 (The quick brown fox jumps over the lazy dog) Tfl
ET
```

This draws a grey rounded rectangle underneath a bit of text.

### Computations - arithmetic operations

Numeric variables, including those returned from operations such as text-measuring instructions, can be used to perform arithmetic operations, whose results are also stored in variables.

The example below again renders text on top of a grey rectangle, but we will give the rectangle some padding.

```
1 0 0 1 10 750 cm
BT
/TimesRoman 12 Tf
$width $height 200 150 (The quick brown fox jumps over the lazy dog)  Tme
ET

$width $width 20 add
$height $height 14 add

0.9 0.9 0.9 RG
0 0 $width $height 10 10 rr f
BT
/TimesRoman 12 Tf
10 7 200 150 (The quick brown fox jumps over the lazy dog) Tfl
ET
```

The arithmetic operations are of the form `<out> <in> <op>` or `<out> <in1> <in2> <op>`, and cover `mov`, `add`, `subs`, `mul`, `div`, `mla` and they accept numeric constants or variables as their `<in>` operands. There is currently no support for chaining of operations.

### Conditional rendering with logical operations

Logical operations act on numerical and boolean variables or constants, and can be used to compare variables. The primary use case for boolean variables is their ability to be used in `if`, `else`, `elseif` constructions, which allow conditional rendering.

In the following example, a rectangle is filled with a red or green colour depending on the value of a variable:

```
# var $level /Number 5

$level 5 lt if
0.6 0 0 rg
$level5 7 lt elseif
0.0.6 0 rg
end
10 10 100 100 10 10 rr f
```

Examples of logical operators are `eq`, `lt`, `lte`, `gt`, `gte`, `not`.

## How to use PDFScript

### Command line utility or API

Use the `pdfs` CLI to process PDFScript from the command-line:

```
pdfs run document.pdfs output.pdf
```

Or use the .NET NuGet package to create PDFs from your .net project.

```
dotnet add package PdfScript
```

```c#
using PagePerfect.PdfScript;

var  doc = new Document(“10 600 100 100 10 10 rr f”);
doc.SaveAs(“Output.pdf”);
```

### Passing variables into scripts

To pass variables into a script using the CLI, use the `—var` switch.

```
pdfs run --var $text /String (Hello, World!) document.pdfs output.pdf
```

To pass variables into a script using the .net API, use the override of the Document initialiser:

```c#
using PagePerfect.PdfScript;

using var output = new MemoryStream();

var doc = new Document(
    “# var $width /Number\r\n$height $width 50 subs 10 600 $width $height re f”,
new { width: 200f });

doc.ToStream(output);
```
